{"ast":null,"code":"/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @typedef {[string, ...Array<Exclude<Properties[keyof Properties], Array<any>> | RegExp>] | string} PropertyDefinition\n *   Definition for a property.\n *\n * @typedef Schema\n *   Schema that defines what nodes and properties are allowed.\n *\n *   The default schema is `defaultSchema`, which follows how GitHub cleans.\n *   If any top-level key is missing in the given schema, the corresponding\n *   value of the default schema is used.\n *\n *   To extend the standard schema with a few changes, clone `defaultSchema`\n *   like so:\n *\n *   ```js\n *   import deepmerge from 'deepmerge'\n *   import {h} from 'hastscript'\n *   import {defaultSchema, sanitize} from 'hast-util-sanitize'\n *\n *   // This allows `className` on all elements.\n *   const schema = deepmerge(defaultSchema, {attributes: {'*': ['className']}})\n *\n *   const tree = sanitize(h('div', {className: ['foo']}), schema)\n *\n *   // `tree` still has `className`.\n *   console.log(tree)\n *   // {\n *   //   type: 'element',\n *   //   tagName: 'div',\n *   //   properties: {className: ['foo']},\n *   //   children: []\n *   // }\n *   ```\n * @property {boolean | null | undefined} [allowComments=false]\n *   Whether to allow comment nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowComments: true\n *   ```\n * @property {boolean | null | undefined} [allowDoctypes=false]\n *   Whether to allow doctype nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowDoctypes: true\n *   ```\n * @property {Record<string, Array<string>> | null | undefined} [ancestors]\n *   Map of tag names to a list of tag names which are required ancestors\n *   (default: `defaultSchema.ancestors`).\n *\n *   Elements with these tag names will be ignored if they occur outside of one\n *   of their allowed parents.\n *\n *   For example:\n *\n *   ```js\n *   ancestors: {\n *     tbody: ['table'],\n *     // â€¦\n *     tr: ['table']\n *   }\n *   ```\n * @property {Record<string, Array<PropertyDefinition>> | null | undefined} [attributes]\n *   Map of tag names to allowed property names (default:\n *   `defaultSchema.attributes`).\n *\n *   The special key `'*'` as a tag name defines property names allowed on all\n *   elements.\n *\n *   The special value `'data*'` as a property name can be used to allow all\n *   `data` properties.\n *\n *   For example:\n *\n *   ```js\n *   attributes: {\n *     'ariaDescribedBy', 'ariaLabel', 'ariaLabelledBy', â€¦, 'href'\n *     // â€¦\n *     '*': [\n *       'abbr',\n *       'accept',\n *       'acceptCharset',\n *       // â€¦\n *       'vAlign',\n *       'value',\n *       'width'\n *     ]\n *   }\n *   ```\n *\n *   Instead of a single string in the array, which allows any property value\n *   for the field, you can use an array to allow several values.\n *   For example, `input: ['type']` allows `type` set to any value on `input`s.\n *   But `input: [['type', 'checkbox', 'radio']]` allows `type` when set to\n *   `'checkbox'` or `'radio'`.\n *\n *   You can use regexes, so for example `span: [['className', /^hljs-/]]`\n *   allows any class that starts with `hljs-` on `span`s.\n *\n *   When comma- or space-separated values are used (such as `className`), each\n *   value in is checked individually.\n *   For example, to allow certain classes on `span`s for syntax highlighting,\n *   use `span: [['className', 'number', 'operator', 'token']]`.\n *   This will allow `'number'`, `'operator'`, and `'token'` classes, but drop\n *   others.\n * @property {Array<string> | null | undefined} [clobber]\n *   List of property names that clobber (default: `defaultSchema.clobber`).\n *\n *   For example:\n *\n *   ```js\n *   clobber: ['ariaDescribedBy', 'ariaLabelledBy', 'id', 'name']\n *   ```\n * @property {string | null | undefined} [clobberPrefix]\n *   Prefix to use before clobbering properties (default:\n *   `defaultSchema.clobberPrefix`).\n *\n *   For example:\n *\n *   ```js\n *   clobberPrefix: 'user-content-'\n *   ```\n * @property {Record<string, Array<string> | null | undefined> | null | undefined} [protocols]\n *   Map of *property names* to allowed protocols (default:\n *   `defaultSchema.protocols`).\n *\n *   This defines URLs that are always allowed to have local URLs (relative to\n *   the current website, such as `this`, `#this`, `/this`, or `?this`), and\n *   only allowed to have remote URLs (such as `https://example.com`) if they\n *   use a known protocol.\n *\n *   For example:\n *\n *   ```js\n *   protocols: {\n *     cite: ['http', 'https'],\n *     // â€¦\n *     src: ['http', 'https']\n *   }\n *   ```\n * @property {Record<string, Record<string, Properties[keyof Properties]>> | null | undefined} [required]\n *   Map of tag names to required property names with a default value\n *   (default: `defaultSchema.required`).\n *\n *   This defines properties that must be set.\n *   If a field does not exist (after the element was made safe), these will be\n *   added with the given value.\n *\n *   For example:\n *\n *   ```js\n *   required: {\n *     input: {disabled: true, type: 'checkbox'}\n *   }\n *   ```\n *\n *   > ðŸ‘‰ **Note**: properties are first checked based on `schema.attributes`,\n *   > then on `schema.required`.\n *   > That means properties could be removed by `attributes` and then added\n *   > again with `required`.\n * @property {Array<string> | null | undefined} [strip]\n *   List of tag names to strip from the tree (default: `defaultSchema.strip`).\n *\n *   By default, unsafe elements (those not in `schema.tagNames`) are replaced\n *   by what they contain.\n *   This option can drop their contents.\n *\n *   For example:\n *\n *   ```js\n *   strip: ['script']\n *   ```\n * @property {Array<string> | null | undefined} [tagNames]\n *   List of allowed tag names (default: `defaultSchema.tagNames`).\n *\n *   For example:\n *\n *   ```js\n *   tagNames: [\n *     'a',\n *     'b',\n *     // â€¦\n *     'ul',\n *     'var'\n *   ]\n *   ```\n *\n * @typedef State\n *   Info passed around.\n * @property {Readonly<Schema>} schema\n *   Schema.\n * @property {Array<string>} stack\n *   Tag names of ancestors.\n */\n\nimport structuredClone from '@ungap/structured-clone';\nimport { position } from 'unist-util-position';\nimport { defaultSchema } from './schema.js';\nconst own = {}.hasOwnProperty;\n\n/**\n * Sanitize a tree.\n *\n * @param {Readonly<Nodes>} node\n *   Unsafe tree.\n * @param {Readonly<Schema> | null | undefined} [options]\n *   Configuration (default: `defaultSchema`).\n * @returns {Nodes}\n *   New, safe tree.\n */\nexport function sanitize(node, options) {\n  /** @type {Nodes} */\n  let ctx = {\n    type: 'root',\n    children: []\n  };\n\n  /** @type {State} */\n  const state = {\n    schema: options ? {\n      ...defaultSchema,\n      ...options\n    } : defaultSchema,\n    stack: []\n  };\n  const replace = transform(state, node);\n  if (replace) {\n    if (Array.isArray(replace)) {\n      if (replace.length === 1) {\n        ctx = replace[0];\n      } else {\n        ctx.children = replace;\n      }\n    } else {\n      ctx = replace;\n    }\n  }\n  return ctx;\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} node\n *   Unsafe node.\n * @returns {Array<ElementContent> | Nodes | undefined}\n *   Safe result.\n */\nfunction transform(state, node) {\n  if (node && typeof node === 'object') {\n    const unsafe = /** @type {Record<string, Readonly<unknown>>} */node;\n    const type = typeof unsafe.type === 'string' ? unsafe.type : '';\n    switch (type) {\n      case 'comment':\n        {\n          return comment(state, unsafe);\n        }\n      case 'doctype':\n        {\n          return doctype(state, unsafe);\n        }\n      case 'element':\n        {\n          return element(state, unsafe);\n        }\n      case 'root':\n        {\n          return root(state, unsafe);\n        }\n      case 'text':\n        {\n          return text(state, unsafe);\n        }\n      default:\n    }\n  }\n}\n\n/**\n * Make a safe comment.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe comment-like value.\n * @returns {Comment | undefined}\n *   Safe comment (if with `allowComments`).\n */\nfunction comment(state, unsafe) {\n  if (state.schema.allowComments) {\n    // See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n    const result = typeof unsafe.value === 'string' ? unsafe.value : '';\n    const index = result.indexOf('-->');\n    const value = index < 0 ? result : result.slice(0, index);\n\n    /** @type {Comment} */\n    const node = {\n      type: 'comment',\n      value\n    };\n    patch(node, unsafe);\n    return node;\n  }\n}\n\n/**\n * Make a safe doctype.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe doctype-like value.\n * @returns {Doctype | undefined}\n *   Safe doctype (if with `allowDoctypes`).\n */\nfunction doctype(state, unsafe) {\n  if (state.schema.allowDoctypes) {\n    /** @type {Doctype} */\n    const node = {\n      type: 'doctype'\n    };\n    patch(node, unsafe);\n    return node;\n  }\n}\n\n/**\n * Make a safe element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe element-like value.\n * @returns {Array<ElementContent> | Element | undefined}\n *   Safe element.\n */\nfunction element(state, unsafe) {\n  const name = typeof unsafe.tagName === 'string' ? unsafe.tagName : '';\n  state.stack.push(name);\n  const content = /** @type {Array<ElementContent>} */\n  children(state, unsafe.children);\n  const props = properties(state, unsafe.properties);\n  state.stack.pop();\n  let safeElement = false;\n  if (name && name !== '*' && (!state.schema.tagNames || state.schema.tagNames.includes(name))) {\n    safeElement = true;\n\n    // Some nodes can break out of their context if they donâ€™t have a certain\n    // ancestor.\n    if (state.schema.ancestors && own.call(state.schema.ancestors, name)) {\n      const ancestors = state.schema.ancestors[name];\n      let index = -1;\n      safeElement = false;\n      while (++index < ancestors.length) {\n        if (state.stack.includes(ancestors[index])) {\n          safeElement = true;\n        }\n      }\n    }\n  }\n  if (!safeElement) {\n    return state.schema.strip && !state.schema.strip.includes(name) ? content : undefined;\n  }\n\n  /** @type {Element} */\n  const node = {\n    type: 'element',\n    tagName: name,\n    properties: props,\n    children: content\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make a safe root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe root-like value.\n * @returns {Root}\n *   Safe root.\n */\nfunction root(state, unsafe) {\n  const content = /** @type {Array<RootContent>} */\n  children(state, unsafe.children);\n\n  /** @type {Root} */\n  const node = {\n    type: 'root',\n    children: content\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make a safe text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe text-like value.\n * @returns {Text}\n *   Safe text.\n */\nfunction text(_, unsafe) {\n  const value = typeof unsafe.value === 'string' ? unsafe.value : '';\n  /** @type {Text} */\n  const node = {\n    type: 'text',\n    value\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make children safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} children\n *   Unsafe value.\n * @returns {Array<Nodes>}\n *   Safe children.\n */\nfunction children(state, children) {\n  /** @type {Array<Nodes>} */\n  const results = [];\n  if (Array.isArray(children)) {\n    const childrenUnknown = /** @type {Array<Readonly<unknown>>} */children;\n    let index = -1;\n    while (++index < childrenUnknown.length) {\n      const value = transform(state, childrenUnknown[index]);\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value);\n        } else {\n          results.push(value);\n        }\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Make element properties safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} properties\n *   Unsafe value.\n * @returns {Properties}\n *   Safe value.\n */\nfunction properties(state, properties) {\n  const tagName = state.stack[state.stack.length - 1];\n  const attributes = state.schema.attributes;\n  const required = state.schema.required;\n  const specific = attributes && own.call(attributes, tagName) ? attributes[tagName] : undefined;\n  const defaults = attributes && own.call(attributes, '*') ? attributes['*'] : undefined;\n  const props = /** @type {Readonly<Record<string, Readonly<unknown>>>} */\n  properties && typeof properties === 'object' ? properties : {};\n  /** @type {Properties} */\n  const result = {};\n  /** @type {string} */\n  let key;\n  for (key in props) {\n    if (own.call(props, key)) {\n      const unsafe = props[key];\n      let safe = propertyValue(state, findDefinition(specific, key), key, unsafe);\n      if (safe === null || safe === undefined) {\n        safe = propertyValue(state, findDefinition(defaults, key), key, unsafe);\n      }\n      if (safe !== null && safe !== undefined) {\n        result[key] = safe;\n      }\n    }\n  }\n  if (required && own.call(required, tagName)) {\n    const properties = required[tagName];\n    for (key in properties) {\n      if (own.call(properties, key) && !own.call(result, key)) {\n        result[key] = properties[key];\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition> | undefined} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but an array).\n * @returns {Array<number | string> | boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValue(state, definition, key, value) {\n  return definition ? Array.isArray(value) ? propertyValueMany(state, definition, key, value) : propertyValuePrimitive(state, definition, key, value) : undefined;\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<Array<Readonly<unknown>>>} values\n *   Unsafe value (but an array).\n * @returns {Array<number | string>}\n *   Safe value.\n */\nfunction propertyValueMany(state, definition, key, values) {\n  let index = -1;\n  /** @type {Array<number | string>} */\n  const result = [];\n  while (++index < values.length) {\n    const value = propertyValuePrimitive(state, definition, key, values[index]);\n    if (typeof value === 'number' || typeof value === 'string') {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value which is a primitive.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but not an array).\n * @returns {boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValuePrimitive(state, definition, key, value) {\n  if (typeof value !== 'boolean' && typeof value !== 'number' && typeof value !== 'string') {\n    return;\n  }\n  if (!safeProtocol(state, key, value)) {\n    return;\n  }\n\n  // Just a string, or only one item in an array, means all values are OK.\n  // More than one item means an allow list.\n  if (typeof definition === 'object' && definition.length > 1) {\n    let ok = false;\n    let index = 0; // Ignore `key`, which is the first item.\n\n    while (++index < definition.length) {\n      const allowed = definition[index];\n\n      // Expression.\n      if (allowed && typeof allowed === 'object' && 'flags' in allowed) {\n        if (allowed.test(String(value))) {\n          ok = true;\n          break;\n        }\n      }\n      // Primitive.\n      else if (allowed === value) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) return;\n  }\n  return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key) ? state.schema.clobberPrefix + value : value;\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value.\n * @returns {boolean}\n *   Whether itâ€™s a safe value.\n */\nfunction safeProtocol(state, key, value) {\n  const protocols = state.schema.protocols && own.call(state.schema.protocols, key) ? state.schema.protocols[key] : undefined;\n\n  // No protocols defined? Then everything is fine.\n  if (!protocols || protocols.length === 0) {\n    return true;\n  }\n  const url = String(value);\n  const colon = url.indexOf(':');\n  const questionMark = url.indexOf('?');\n  const numberSign = url.indexOf('#');\n  const slash = url.indexOf('/');\n  if (colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {\n    return true;\n  }\n  let index = -1;\n  while (++index < protocols.length) {\n    const protocol = protocols[index];\n    if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Add data and position.\n *\n * @param {Nodes} node\n *   Node to patch safe data and position on.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe node-like value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(node, unsafe) {\n  const cleanPosition = position(\n  // @ts-expect-error: looks like a node.\n  unsafe);\n  if (unsafe.data) {\n    node.data = structuredClone(unsafe.data);\n  }\n  if (cleanPosition) node.position = cleanPosition;\n}\n\n/**\n *\n * @param {Readonly<Array<PropertyDefinition>> | undefined} definitions\n * @param {string} key\n * @returns {Readonly<PropertyDefinition> | undefined}\n */\nfunction findDefinition(definitions, key) {\n  /** @type {PropertyDefinition | undefined} */\n  let dataDefault;\n  let index = -1;\n  if (definitions) {\n    while (++index < definitions.length) {\n      const entry = definitions[index];\n      const name = typeof entry === 'string' ? entry : entry[0];\n      if (name === key) {\n        return entry;\n      }\n      if (name === 'data*') dataDefault = entry;\n    }\n  }\n  if (key.length > 4 && key.slice(0, 4).toLowerCase() === 'data') {\n    return dataDefault;\n  }\n}","map":{"version":3,"names":["structuredClone","position","defaultSchema","own","hasOwnProperty","sanitize","node","options","ctx","type","children","state","schema","stack","replace","transform","Array","isArray","length","unsafe","comment","doctype","element","root","text","allowComments","result","value","index","indexOf","slice","patch","allowDoctypes","name","tagName","push","content","props","properties","pop","safeElement","tagNames","includes","ancestors","call","strip","undefined","_","results","childrenUnknown","attributes","required","specific","defaults","key","safe","propertyValue","findDefinition","definition","propertyValueMany","propertyValuePrimitive","values","safeProtocol","ok","allowed","test","String","clobber","clobberPrefix","protocols","url","colon","questionMark","numberSign","slash","protocol","cleanPosition","data","definitions","dataDefault","entry","toLowerCase"],"sources":["/Users/antone.king/dev/speedrun-attention/node_modules/hast-util-sanitize/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @typedef {[string, ...Array<Exclude<Properties[keyof Properties], Array<any>> | RegExp>] | string} PropertyDefinition\n *   Definition for a property.\n *\n * @typedef Schema\n *   Schema that defines what nodes and properties are allowed.\n *\n *   The default schema is `defaultSchema`, which follows how GitHub cleans.\n *   If any top-level key is missing in the given schema, the corresponding\n *   value of the default schema is used.\n *\n *   To extend the standard schema with a few changes, clone `defaultSchema`\n *   like so:\n *\n *   ```js\n *   import deepmerge from 'deepmerge'\n *   import {h} from 'hastscript'\n *   import {defaultSchema, sanitize} from 'hast-util-sanitize'\n *\n *   // This allows `className` on all elements.\n *   const schema = deepmerge(defaultSchema, {attributes: {'*': ['className']}})\n *\n *   const tree = sanitize(h('div', {className: ['foo']}), schema)\n *\n *   // `tree` still has `className`.\n *   console.log(tree)\n *   // {\n *   //   type: 'element',\n *   //   tagName: 'div',\n *   //   properties: {className: ['foo']},\n *   //   children: []\n *   // }\n *   ```\n * @property {boolean | null | undefined} [allowComments=false]\n *   Whether to allow comment nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowComments: true\n *   ```\n * @property {boolean | null | undefined} [allowDoctypes=false]\n *   Whether to allow doctype nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowDoctypes: true\n *   ```\n * @property {Record<string, Array<string>> | null | undefined} [ancestors]\n *   Map of tag names to a list of tag names which are required ancestors\n *   (default: `defaultSchema.ancestors`).\n *\n *   Elements with these tag names will be ignored if they occur outside of one\n *   of their allowed parents.\n *\n *   For example:\n *\n *   ```js\n *   ancestors: {\n *     tbody: ['table'],\n *     // â€¦\n *     tr: ['table']\n *   }\n *   ```\n * @property {Record<string, Array<PropertyDefinition>> | null | undefined} [attributes]\n *   Map of tag names to allowed property names (default:\n *   `defaultSchema.attributes`).\n *\n *   The special key `'*'` as a tag name defines property names allowed on all\n *   elements.\n *\n *   The special value `'data*'` as a property name can be used to allow all\n *   `data` properties.\n *\n *   For example:\n *\n *   ```js\n *   attributes: {\n *     'ariaDescribedBy', 'ariaLabel', 'ariaLabelledBy', â€¦, 'href'\n *     // â€¦\n *     '*': [\n *       'abbr',\n *       'accept',\n *       'acceptCharset',\n *       // â€¦\n *       'vAlign',\n *       'value',\n *       'width'\n *     ]\n *   }\n *   ```\n *\n *   Instead of a single string in the array, which allows any property value\n *   for the field, you can use an array to allow several values.\n *   For example, `input: ['type']` allows `type` set to any value on `input`s.\n *   But `input: [['type', 'checkbox', 'radio']]` allows `type` when set to\n *   `'checkbox'` or `'radio'`.\n *\n *   You can use regexes, so for example `span: [['className', /^hljs-/]]`\n *   allows any class that starts with `hljs-` on `span`s.\n *\n *   When comma- or space-separated values are used (such as `className`), each\n *   value in is checked individually.\n *   For example, to allow certain classes on `span`s for syntax highlighting,\n *   use `span: [['className', 'number', 'operator', 'token']]`.\n *   This will allow `'number'`, `'operator'`, and `'token'` classes, but drop\n *   others.\n * @property {Array<string> | null | undefined} [clobber]\n *   List of property names that clobber (default: `defaultSchema.clobber`).\n *\n *   For example:\n *\n *   ```js\n *   clobber: ['ariaDescribedBy', 'ariaLabelledBy', 'id', 'name']\n *   ```\n * @property {string | null | undefined} [clobberPrefix]\n *   Prefix to use before clobbering properties (default:\n *   `defaultSchema.clobberPrefix`).\n *\n *   For example:\n *\n *   ```js\n *   clobberPrefix: 'user-content-'\n *   ```\n * @property {Record<string, Array<string> | null | undefined> | null | undefined} [protocols]\n *   Map of *property names* to allowed protocols (default:\n *   `defaultSchema.protocols`).\n *\n *   This defines URLs that are always allowed to have local URLs (relative to\n *   the current website, such as `this`, `#this`, `/this`, or `?this`), and\n *   only allowed to have remote URLs (such as `https://example.com`) if they\n *   use a known protocol.\n *\n *   For example:\n *\n *   ```js\n *   protocols: {\n *     cite: ['http', 'https'],\n *     // â€¦\n *     src: ['http', 'https']\n *   }\n *   ```\n * @property {Record<string, Record<string, Properties[keyof Properties]>> | null | undefined} [required]\n *   Map of tag names to required property names with a default value\n *   (default: `defaultSchema.required`).\n *\n *   This defines properties that must be set.\n *   If a field does not exist (after the element was made safe), these will be\n *   added with the given value.\n *\n *   For example:\n *\n *   ```js\n *   required: {\n *     input: {disabled: true, type: 'checkbox'}\n *   }\n *   ```\n *\n *   > ðŸ‘‰ **Note**: properties are first checked based on `schema.attributes`,\n *   > then on `schema.required`.\n *   > That means properties could be removed by `attributes` and then added\n *   > again with `required`.\n * @property {Array<string> | null | undefined} [strip]\n *   List of tag names to strip from the tree (default: `defaultSchema.strip`).\n *\n *   By default, unsafe elements (those not in `schema.tagNames`) are replaced\n *   by what they contain.\n *   This option can drop their contents.\n *\n *   For example:\n *\n *   ```js\n *   strip: ['script']\n *   ```\n * @property {Array<string> | null | undefined} [tagNames]\n *   List of allowed tag names (default: `defaultSchema.tagNames`).\n *\n *   For example:\n *\n *   ```js\n *   tagNames: [\n *     'a',\n *     'b',\n *     // â€¦\n *     'ul',\n *     'var'\n *   ]\n *   ```\n *\n * @typedef State\n *   Info passed around.\n * @property {Readonly<Schema>} schema\n *   Schema.\n * @property {Array<string>} stack\n *   Tag names of ancestors.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {position} from 'unist-util-position'\nimport {defaultSchema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Sanitize a tree.\n *\n * @param {Readonly<Nodes>} node\n *   Unsafe tree.\n * @param {Readonly<Schema> | null | undefined} [options]\n *   Configuration (default: `defaultSchema`).\n * @returns {Nodes}\n *   New, safe tree.\n */\nexport function sanitize(node, options) {\n  /** @type {Nodes} */\n  let ctx = {type: 'root', children: []}\n\n  /** @type {State} */\n  const state = {\n    schema: options ? {...defaultSchema, ...options} : defaultSchema,\n    stack: []\n  }\n  const replace = transform(state, node)\n\n  if (replace) {\n    if (Array.isArray(replace)) {\n      if (replace.length === 1) {\n        ctx = replace[0]\n      } else {\n        ctx.children = replace\n      }\n    } else {\n      ctx = replace\n    }\n  }\n\n  return ctx\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} node\n *   Unsafe node.\n * @returns {Array<ElementContent> | Nodes | undefined}\n *   Safe result.\n */\nfunction transform(state, node) {\n  if (node && typeof node === 'object') {\n    const unsafe = /** @type {Record<string, Readonly<unknown>>} */ (node)\n    const type = typeof unsafe.type === 'string' ? unsafe.type : ''\n\n    switch (type) {\n      case 'comment': {\n        return comment(state, unsafe)\n      }\n\n      case 'doctype': {\n        return doctype(state, unsafe)\n      }\n\n      case 'element': {\n        return element(state, unsafe)\n      }\n\n      case 'root': {\n        return root(state, unsafe)\n      }\n\n      case 'text': {\n        return text(state, unsafe)\n      }\n\n      default:\n    }\n  }\n}\n\n/**\n * Make a safe comment.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe comment-like value.\n * @returns {Comment | undefined}\n *   Safe comment (if with `allowComments`).\n */\nfunction comment(state, unsafe) {\n  if (state.schema.allowComments) {\n    // See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n    const result = typeof unsafe.value === 'string' ? unsafe.value : ''\n    const index = result.indexOf('-->')\n    const value = index < 0 ? result : result.slice(0, index)\n\n    /** @type {Comment} */\n    const node = {type: 'comment', value}\n\n    patch(node, unsafe)\n\n    return node\n  }\n}\n\n/**\n * Make a safe doctype.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe doctype-like value.\n * @returns {Doctype | undefined}\n *   Safe doctype (if with `allowDoctypes`).\n */\nfunction doctype(state, unsafe) {\n  if (state.schema.allowDoctypes) {\n    /** @type {Doctype} */\n    const node = {type: 'doctype'}\n\n    patch(node, unsafe)\n\n    return node\n  }\n}\n\n/**\n * Make a safe element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe element-like value.\n * @returns {Array<ElementContent> | Element | undefined}\n *   Safe element.\n */\nfunction element(state, unsafe) {\n  const name = typeof unsafe.tagName === 'string' ? unsafe.tagName : ''\n\n  state.stack.push(name)\n\n  const content = /** @type {Array<ElementContent>} */ (\n    children(state, unsafe.children)\n  )\n  const props = properties(state, unsafe.properties)\n\n  state.stack.pop()\n\n  let safeElement = false\n\n  if (\n    name &&\n    name !== '*' &&\n    (!state.schema.tagNames || state.schema.tagNames.includes(name))\n  ) {\n    safeElement = true\n\n    // Some nodes can break out of their context if they donâ€™t have a certain\n    // ancestor.\n    if (state.schema.ancestors && own.call(state.schema.ancestors, name)) {\n      const ancestors = state.schema.ancestors[name]\n      let index = -1\n\n      safeElement = false\n\n      while (++index < ancestors.length) {\n        if (state.stack.includes(ancestors[index])) {\n          safeElement = true\n        }\n      }\n    }\n  }\n\n  if (!safeElement) {\n    return state.schema.strip && !state.schema.strip.includes(name)\n      ? content\n      : undefined\n  }\n\n  /** @type {Element} */\n  const node = {\n    type: 'element',\n    tagName: name,\n    properties: props,\n    children: content\n  }\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make a safe root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe root-like value.\n * @returns {Root}\n *   Safe root.\n */\nfunction root(state, unsafe) {\n  const content = /** @type {Array<RootContent>} */ (\n    children(state, unsafe.children)\n  )\n\n  /** @type {Root} */\n  const node = {type: 'root', children: content}\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make a safe text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe text-like value.\n * @returns {Text}\n *   Safe text.\n */\nfunction text(_, unsafe) {\n  const value = typeof unsafe.value === 'string' ? unsafe.value : ''\n  /** @type {Text} */\n  const node = {type: 'text', value}\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make children safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} children\n *   Unsafe value.\n * @returns {Array<Nodes>}\n *   Safe children.\n */\nfunction children(state, children) {\n  /** @type {Array<Nodes>} */\n  const results = []\n\n  if (Array.isArray(children)) {\n    const childrenUnknown = /** @type {Array<Readonly<unknown>>} */ (children)\n    let index = -1\n\n    while (++index < childrenUnknown.length) {\n      const value = transform(state, childrenUnknown[index])\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value)\n        } else {\n          results.push(value)\n        }\n      }\n    }\n  }\n\n  return results\n}\n\n/**\n * Make element properties safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} properties\n *   Unsafe value.\n * @returns {Properties}\n *   Safe value.\n */\nfunction properties(state, properties) {\n  const tagName = state.stack[state.stack.length - 1]\n  const attributes = state.schema.attributes\n  const required = state.schema.required\n  const specific =\n    attributes && own.call(attributes, tagName)\n      ? attributes[tagName]\n      : undefined\n  const defaults =\n    attributes && own.call(attributes, '*') ? attributes['*'] : undefined\n  const props = /** @type {Readonly<Record<string, Readonly<unknown>>>} */ (\n    properties && typeof properties === 'object' ? properties : {}\n  )\n  /** @type {Properties} */\n  const result = {}\n  /** @type {string} */\n  let key\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      const unsafe = props[key]\n      let safe = propertyValue(\n        state,\n        findDefinition(specific, key),\n        key,\n        unsafe\n      )\n\n      if (safe === null || safe === undefined) {\n        safe = propertyValue(state, findDefinition(defaults, key), key, unsafe)\n      }\n\n      if (safe !== null && safe !== undefined) {\n        result[key] = safe\n      }\n    }\n  }\n\n  if (required && own.call(required, tagName)) {\n    const properties = required[tagName]\n\n    for (key in properties) {\n      if (own.call(properties, key) && !own.call(result, key)) {\n        result[key] = properties[key]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition> | undefined} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but an array).\n * @returns {Array<number | string> | boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValue(state, definition, key, value) {\n  return definition\n    ? Array.isArray(value)\n      ? propertyValueMany(state, definition, key, value)\n      : propertyValuePrimitive(state, definition, key, value)\n    : undefined\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<Array<Readonly<unknown>>>} values\n *   Unsafe value (but an array).\n * @returns {Array<number | string>}\n *   Safe value.\n */\nfunction propertyValueMany(state, definition, key, values) {\n  let index = -1\n  /** @type {Array<number | string>} */\n  const result = []\n\n  while (++index < values.length) {\n    const value = propertyValuePrimitive(state, definition, key, values[index])\n\n    if (typeof value === 'number' || typeof value === 'string') {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value which is a primitive.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but not an array).\n * @returns {boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValuePrimitive(state, definition, key, value) {\n  if (\n    typeof value !== 'boolean' &&\n    typeof value !== 'number' &&\n    typeof value !== 'string'\n  ) {\n    return\n  }\n\n  if (!safeProtocol(state, key, value)) {\n    return\n  }\n\n  // Just a string, or only one item in an array, means all values are OK.\n  // More than one item means an allow list.\n  if (typeof definition === 'object' && definition.length > 1) {\n    let ok = false\n    let index = 0 // Ignore `key`, which is the first item.\n\n    while (++index < definition.length) {\n      const allowed = definition[index]\n\n      // Expression.\n      if (allowed && typeof allowed === 'object' && 'flags' in allowed) {\n        if (allowed.test(String(value))) {\n          ok = true\n          break\n        }\n      }\n      // Primitive.\n      else if (allowed === value) {\n        ok = true\n        break\n      }\n    }\n\n    if (!ok) return\n  }\n\n  return state.schema.clobber &&\n    state.schema.clobberPrefix &&\n    state.schema.clobber.includes(key)\n    ? state.schema.clobberPrefix + value\n    : value\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value.\n * @returns {boolean}\n *   Whether itâ€™s a safe value.\n */\nfunction safeProtocol(state, key, value) {\n  const protocols =\n    state.schema.protocols && own.call(state.schema.protocols, key)\n      ? state.schema.protocols[key]\n      : undefined\n\n  // No protocols defined? Then everything is fine.\n  if (!protocols || protocols.length === 0) {\n    return true\n  }\n\n  const url = String(value)\n  const colon = url.indexOf(':')\n  const questionMark = url.indexOf('?')\n  const numberSign = url.indexOf('#')\n  const slash = url.indexOf('/')\n\n  if (\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign)\n  ) {\n    return true\n  }\n\n  let index = -1\n\n  while (++index < protocols.length) {\n    const protocol = protocols[index]\n\n    if (\n      colon === protocol.length &&\n      url.slice(0, protocol.length) === protocol\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Add data and position.\n *\n * @param {Nodes} node\n *   Node to patch safe data and position on.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe node-like value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(node, unsafe) {\n  const cleanPosition = position(\n    // @ts-expect-error: looks like a node.\n    unsafe\n  )\n\n  if (unsafe.data) {\n    node.data = structuredClone(unsafe.data)\n  }\n\n  if (cleanPosition) node.position = cleanPosition\n}\n\n/**\n *\n * @param {Readonly<Array<PropertyDefinition>> | undefined} definitions\n * @param {string} key\n * @returns {Readonly<PropertyDefinition> | undefined}\n */\nfunction findDefinition(definitions, key) {\n  /** @type {PropertyDefinition | undefined} */\n  let dataDefault\n  let index = -1\n\n  if (definitions) {\n    while (++index < definitions.length) {\n      const entry = definitions[index]\n      const name = typeof entry === 'string' ? entry : entry[0]\n\n      if (name === key) {\n        return entry\n      }\n\n      if (name === 'data*') dataDefault = entry\n    }\n  }\n\n  if (key.length > 4 && key.slice(0, 4).toLowerCase() === 'data') {\n    return dataDefault\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,eAAe,MAAM,yBAAyB;AACrD,SAAQC,QAAQ,QAAO,qBAAqB;AAC5C,SAAQC,aAAa,QAAO,aAAa;AAEzC,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}