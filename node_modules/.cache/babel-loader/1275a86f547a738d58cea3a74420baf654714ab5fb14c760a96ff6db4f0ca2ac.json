{"ast":null,"code":"/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @typedef {[string, ...Array<Exclude<Properties[keyof Properties], Array<any>> | RegExp>] | string} PropertyDefinition\n *   Definition for a property.\n *\n * @typedef Schema\n *   Schema that defines what nodes and properties are allowed.\n *\n *   The default schema is `defaultSchema`, which follows how GitHub cleans.\n *   If any top-level key is missing in the given schema, the corresponding\n *   value of the default schema is used.\n *\n *   To extend the standard schema with a few changes, clone `defaultSchema`\n *   like so:\n *\n *   ```js\n *   import deepmerge from 'deepmerge'\n *   import {h} from 'hastscript'\n *   import {defaultSchema, sanitize} from 'hast-util-sanitize'\n *\n *   // This allows `className` on all elements.\n *   const schema = deepmerge(defaultSchema, {attributes: {'*': ['className']}})\n *\n *   const tree = sanitize(h('div', {className: ['foo']}), schema)\n *\n *   // `tree` still has `className`.\n *   console.log(tree)\n *   // {\n *   //   type: 'element',\n *   //   tagName: 'div',\n *   //   properties: {className: ['foo']},\n *   //   children: []\n *   // }\n *   ```\n * @property {boolean | null | undefined} [allowComments=false]\n *   Whether to allow comment nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowComments: true\n *   ```\n * @property {boolean | null | undefined} [allowDoctypes=false]\n *   Whether to allow doctype nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowDoctypes: true\n *   ```\n * @property {Record<string, Array<string>> | null | undefined} [ancestors]\n *   Map of tag names to a list of tag names which are required ancestors\n *   (default: `defaultSchema.ancestors`).\n *\n *   Elements with these tag names will be ignored if they occur outside of one\n *   of their allowed parents.\n *\n *   For example:\n *\n *   ```js\n *   ancestors: {\n *     tbody: ['table'],\n *     // â€¦\n *     tr: ['table']\n *   }\n *   ```\n * @property {Record<string, Array<PropertyDefinition>> | null | undefined} [attributes]\n *   Map of tag names to allowed property names (default:\n *   `defaultSchema.attributes`).\n *\n *   The special key `'*'` as a tag name defines property names allowed on all\n *   elements.\n *\n *   The special value `'data*'` as a property name can be used to allow all\n *   `data` properties.\n *\n *   For example:\n *\n *   ```js\n *   attributes: {\n *     'ariaDescribedBy', 'ariaLabel', 'ariaLabelledBy', â€¦, 'href'\n *     // â€¦\n *     '*': [\n *       'abbr',\n *       'accept',\n *       'acceptCharset',\n *       // â€¦\n *       'vAlign',\n *       'value',\n *       'width'\n *     ]\n *   }\n *   ```\n *\n *   Instead of a single string in the array, which allows any property value\n *   for the field, you can use an array to allow several values.\n *   For example, `input: ['type']` allows `type` set to any value on `input`s.\n *   But `input: [['type', 'checkbox', 'radio']]` allows `type` when set to\n *   `'checkbox'` or `'radio'`.\n *\n *   You can use regexes, so for example `span: [['className', /^hljs-/]]`\n *   allows any class that starts with `hljs-` on `span`s.\n *\n *   When comma- or space-separated values are used (such as `className`), each\n *   value in is checked individually.\n *   For example, to allow certain classes on `span`s for syntax highlighting,\n *   use `span: [['className', 'number', 'operator', 'token']]`.\n *   This will allow `'number'`, `'operator'`, and `'token'` classes, but drop\n *   others.\n * @property {Array<string> | null | undefined} [clobber]\n *   List of property names that clobber (default: `defaultSchema.clobber`).\n *\n *   For example:\n *\n *   ```js\n *   clobber: ['ariaDescribedBy', 'ariaLabelledBy', 'id', 'name']\n *   ```\n * @property {string | null | undefined} [clobberPrefix]\n *   Prefix to use before clobbering properties (default:\n *   `defaultSchema.clobberPrefix`).\n *\n *   For example:\n *\n *   ```js\n *   clobberPrefix: 'user-content-'\n *   ```\n * @property {Record<string, Array<string> | null | undefined> | null | undefined} [protocols]\n *   Map of *property names* to allowed protocols (default:\n *   `defaultSchema.protocols`).\n *\n *   This defines URLs that are always allowed to have local URLs (relative to\n *   the current website, such as `this`, `#this`, `/this`, or `?this`), and\n *   only allowed to have remote URLs (such as `https://example.com`) if they\n *   use a known protocol.\n *\n *   For example:\n *\n *   ```js\n *   protocols: {\n *     cite: ['http', 'https'],\n *     // â€¦\n *     src: ['http', 'https']\n *   }\n *   ```\n * @property {Record<string, Record<string, Properties[keyof Properties]>> | null | undefined} [required]\n *   Map of tag names to required property names with a default value\n *   (default: `defaultSchema.required`).\n *\n *   This defines properties that must be set.\n *   If a field does not exist (after the element was made safe), these will be\n *   added with the given value.\n *\n *   For example:\n *\n *   ```js\n *   required: {\n *     input: {disabled: true, type: 'checkbox'}\n *   }\n *   ```\n *\n *   > ðŸ‘‰ **Note**: properties are first checked based on `schema.attributes`,\n *   > then on `schema.required`.\n *   > That means properties could be removed by `attributes` and then added\n *   > again with `required`.\n * @property {Array<string> | null | undefined} [strip]\n *   List of tag names to strip from the tree (default: `defaultSchema.strip`).\n *\n *   By default, unsafe elements (those not in `schema.tagNames`) are replaced\n *   by what they contain.\n *   This option can drop their contents.\n *\n *   For example:\n *\n *   ```js\n *   strip: ['script']\n *   ```\n * @property {Array<string> | null | undefined} [tagNames]\n *   List of allowed tag names (default: `defaultSchema.tagNames`).\n *\n *   For example:\n *\n *   ```js\n *   tagNames: [\n *     'a',\n *     'b',\n *     // â€¦\n *     'ul',\n *     'var'\n *   ]\n *   ```\n *\n * @typedef State\n *   Info passed around.\n * @property {Readonly<Schema>} schema\n *   Schema.\n * @property {Array<string>} stack\n *   Tag names of ancestors.\n */\n\nimport structuredClone from '@ungap/structured-clone';\nimport { position } from 'unist-util-position';\nimport { defaultSchema } from './schema.js';\nconst own = {}.hasOwnProperty;\n\n/**\n * Sanitize a tree.\n *\n * @param {Readonly<Nodes>} node\n *   Unsafe tree.\n * @param {Readonly<Schema> | null | undefined} [options]\n *   Configuration (default: `defaultSchema`).\n * @returns {Nodes}\n *   New, safe tree.\n */\nexport function sanitize(node, options) {\n  /** @type {Nodes} */\n  let ctx = {\n    type: 'root',\n    children: []\n  };\n\n  /** @type {State} */\n  const state = {\n    schema: options ? {\n      ...defaultSchema,\n      ...options\n    } : defaultSchema,\n    stack: []\n  };\n  const replace = transform(state, node);\n  if (replace) {\n    if (Array.isArray(replace)) {\n      if (replace.length === 1) {\n        ctx = replace[0];\n      } else {\n        ctx.children = replace;\n      }\n    } else {\n      ctx = replace;\n    }\n  }\n  return ctx;\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} node\n *   Unsafe node.\n * @returns {Array<ElementContent> | Nodes | undefined}\n *   Safe result.\n */\nfunction transform(state, node) {\n  if (node && typeof node === 'object') {\n    const unsafe = /** @type {Record<string, Readonly<unknown>>} */node;\n    const type = typeof unsafe.type === 'string' ? unsafe.type : '';\n    switch (type) {\n      case 'comment':\n        {\n          return comment(state, unsafe);\n        }\n      case 'doctype':\n        {\n          return doctype(state, unsafe);\n        }\n      case 'element':\n        {\n          return element(state, unsafe);\n        }\n      case 'root':\n        {\n          return root(state, unsafe);\n        }\n      case 'text':\n        {\n          return text(state, unsafe);\n        }\n      default:\n    }\n  }\n}\n\n/**\n * Make a safe comment.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe comment-like value.\n * @returns {Comment | undefined}\n *   Safe comment (if with `allowComments`).\n */\nfunction comment(state, unsafe) {\n  if (state.schema.allowComments) {\n    // See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n    const result = typeof unsafe.value === 'string' ? unsafe.value : '';\n    const index = result.indexOf('-->');\n    const value = index < 0 ? result : result.slice(0, index);\n\n    /** @type {Comment} */\n    const node = {\n      type: 'comment',\n      value\n    };\n    patch(node, unsafe);\n    return node;\n  }\n}\n\n/**\n * Make a safe doctype.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe doctype-like value.\n * @returns {Doctype | undefined}\n *   Safe doctype (if with `allowDoctypes`).\n */\nfunction doctype(state, unsafe) {\n  if (state.schema.allowDoctypes) {\n    /** @type {Doctype} */\n    const node = {\n      type: 'doctype'\n    };\n    patch(node, unsafe);\n    return node;\n  }\n}\n\n/**\n * Make a safe element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe element-like value.\n * @returns {Array<ElementContent> | Element | undefined}\n *   Safe element.\n */\nfunction element(state, unsafe) {\n  const name = typeof unsafe.tagName === 'string' ? unsafe.tagName : '';\n  state.stack.push(name);\n  const content = /** @type {Array<ElementContent>} */\n  children(state, unsafe.children);\n  const props = properties(state, unsafe.properties);\n  state.stack.pop();\n  let safeElement = false;\n  if (name && name !== '*' && (!state.schema.tagNames || state.schema.tagNames.includes(name))) {\n    safeElement = true;\n\n    // Some nodes can break out of their context if they donâ€™t have a certain\n    // ancestor.\n    if (state.schema.ancestors && own.call(state.schema.ancestors, name)) {\n      const ancestors = state.schema.ancestors[name];\n      let index = -1;\n      safeElement = false;\n      while (++index < ancestors.length) {\n        if (state.stack.includes(ancestors[index])) {\n          safeElement = true;\n        }\n      }\n    }\n  }\n  if (!safeElement) {\n    return state.schema.strip && !state.schema.strip.includes(name) ? content : undefined;\n  }\n\n  /** @type {Element} */\n  const node = {\n    type: 'element',\n    tagName: name,\n    properties: props,\n    children: content\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make a safe root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe root-like value.\n * @returns {Root}\n *   Safe root.\n */\nfunction root(state, unsafe) {\n  const content = /** @type {Array<RootContent>} */\n  children(state, unsafe.children);\n\n  /** @type {Root} */\n  const node = {\n    type: 'root',\n    children: content\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make a safe text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe text-like value.\n * @returns {Text}\n *   Safe text.\n */\nfunction text(_, unsafe) {\n  const value = typeof unsafe.value === 'string' ? unsafe.value : '';\n  /** @type {Text} */\n  const node = {\n    type: 'text',\n    value\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make children safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} children\n *   Unsafe value.\n * @returns {Array<Nodes>}\n *   Safe children.\n */\nfunction children(state, children) {\n  /** @type {Array<Nodes>} */\n  const results = [];\n  if (Array.isArray(children)) {\n    const childrenUnknown = /** @type {Array<Readonly<unknown>>} */children;\n    let index = -1;\n    while (++index < childrenUnknown.length) {\n      const value = transform(state, childrenUnknown[index]);\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value);\n        } else {\n          results.push(value);\n        }\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Make element properties safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} properties\n *   Unsafe value.\n * @returns {Properties}\n *   Safe value.\n */\nfunction properties(state, properties) {\n  const tagName = state.stack[state.stack.length - 1];\n  const attributes = state.schema.attributes;\n  const required = state.schema.required;\n  const specific = attributes && own.call(attributes, tagName) ? attributes[tagName] : undefined;\n  const defaults = attributes && own.call(attributes, '*') ? attributes['*'] : undefined;\n  const props = /** @type {Readonly<Record<string, Readonly<unknown>>>} */\n  properties && typeof properties === 'object' ? properties : {};\n  /** @type {Properties} */\n  const result = {};\n  /** @type {string} */\n  let key;\n  for (key in props) {\n    if (own.call(props, key)) {\n      const unsafe = props[key];\n      let safe = propertyValue(state, findDefinition(specific, key), key, unsafe);\n      if (safe === null || safe === undefined) {\n        safe = propertyValue(state, findDefinition(defaults, key), key, unsafe);\n      }\n      if (safe !== null && safe !== undefined) {\n        result[key] = safe;\n      }\n    }\n  }\n  if (required && own.call(required, tagName)) {\n    const properties = required[tagName];\n    for (key in properties) {\n      if (own.call(properties, key) && !own.call(result, key)) {\n        result[key] = properties[key];\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition> | undefined} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but an array).\n * @returns {Array<number | string> | boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValue(state, definition, key, value) {\n  return definition ? Array.isArray(value) ? propertyValueMany(state, definition, key, value) : propertyValuePrimitive(state, definition, key, value) : undefined;\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<Array<Readonly<unknown>>>} values\n *   Unsafe value (but an array).\n * @returns {Array<number | string>}\n *   Safe value.\n */\nfunction propertyValueMany(state, definition, key, values) {\n  let index = -1;\n  /** @type {Array<number | string>} */\n  const result = [];\n  while (++index < values.length) {\n    const value = propertyValuePrimitive(state, definition, key, values[index]);\n    if (typeof value === 'number' || typeof value === 'string') {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value which is a primitive.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but not an array).\n * @returns {boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValuePrimitive(state, definition, key, value) {\n  if (typeof value !== 'boolean' && typeof value !== 'number' && typeof value !== 'string') {\n    return;\n  }\n  if (!safeProtocol(state, key, value)) {\n    return;\n  }\n\n  // Just a string, or only one item in an array, means all values are OK.\n  // More than one item means an allow list.\n  if (typeof definition === 'object' && definition.length > 1) {\n    let ok = false;\n    let index = 0; // Ignore `key`, which is the first item.\n\n    while (++index < definition.length) {\n      const allowed = definition[index];\n\n      // Expression.\n      if (allowed && typeof allowed === 'object' && 'flags' in allowed) {\n        if (allowed.test(String(value))) {\n          ok = true;\n          break;\n        }\n      }\n      // Primitive.\n      else if (allowed === value) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) return;\n  }\n  return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key) ? state.schema.clobberPrefix + value : value;\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value.\n * @returns {boolean}\n *   Whether itâ€™s a safe value.\n */\nfunction safeProtocol(state, key, value) {\n  const protocols = state.schema.protocols && own.call(state.schema.protocols, key) ? state.schema.protocols[key] : undefined;\n\n  // No protocols defined? Then everything is fine.\n  if (!protocols || protocols.length === 0) {\n    return true;\n  }\n  const url = String(value);\n  const colon = url.indexOf(':');\n  const questionMark = url.indexOf('?');\n  const numberSign = url.indexOf('#');\n  const slash = url.indexOf('/');\n  if (colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {\n    return true;\n  }\n  let index = -1;\n  while (++index < protocols.length) {\n    const protocol = protocols[index];\n    if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Add data and position.\n *\n * @param {Nodes} node\n *   Node to patch safe data and position on.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe node-like value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(node, unsafe) {\n  const cleanPosition = position(\n  // @ts-expect-error: looks like a node.\n  unsafe);\n  if (unsafe.data) {\n    node.data = structuredClone(unsafe.data);\n  }\n  if (cleanPosition) node.position = cleanPosition;\n}\n\n/**\n *\n * @param {Readonly<Array<PropertyDefinition>> | undefined} definitions\n * @param {string} key\n * @returns {Readonly<PropertyDefinition> | undefined}\n */\nfunction findDefinition(definitions, key) {\n  /** @type {PropertyDefinition | undefined} */\n  let dataDefault;\n  let index = -1;\n  if (definitions) {\n    while (++index < definitions.length) {\n      const entry = definitions[index];\n      const name = typeof entry === 'string' ? entry : entry[0];\n      if (name === key) {\n        return entry;\n      }\n      if (name === 'data*') dataDefault = entry;\n    }\n  }\n  if (key.length > 4 && key.slice(0, 4).toLowerCase() === 'data') {\n    return dataDefault;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}